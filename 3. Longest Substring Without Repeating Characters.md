# 3. Longest Substring Without Repeating Characters

## 題目概述

給定一字串，去掉重複出現的字符後，得到出新的字串，計算心字串的長度

## 暴力解

1. 找出所有可能的字符集合，花費時間 $O(n^2)$[^1][^2]
2. 利用Hash Table或者Array，再逐一掃描是否包含重複字符 $O(n)$

總共花費時間（理論上） $O(n^3)$

補充：Leetcode的字符都是ASCII，只有128種不同字元，就算將Leetcode所有的字符組成一獨立不重複的字串，長度最長也就是128，因此：

* 總花費時間（Leetcode實際上）為 $O(128^2 \times n)$
* 空間複雜度（Leetcode實際上）為 $O(128)$



[^1]: 決定substring的起點，往後找出所有可能組合，假設字串為`abcde`，先從`a`開始看，列出`a`、`ab`、`abc`、`abcd`、`abcde`，再從`b`開始看，列出`b`、`bc`、`bcd`、`bcde`，以下類推
[^2]: 實際的複雜度為n×(n+1)/2，類似三角形的底×高/2算法，由於n×(n+1)/2在無限大資料下跟n^2差異不大，因此也可以說他就是n^2級別的算法

## 暴力解優化

優化前面算法，遍歷所有集合的同時，計算算是否重複

### 解題思維

本解法一共有2層迴圈，外層for迴圈，內層while迴圈  
while迴圈是縣市選拔，for迴圈是全國比賽，比賽流程類似這樣：

1. 在比賽開始之前，定義暫時全國第一名為小明，分數為0
2. 舉辦基隆市比賽，選出基隆市冠軍小昌，分數為4
3. 因為4>0，小昌取代小明，暫代全國第一名
4. 舉辦台北市比賽，選出台北市冠軍小哲，分數為3
5. 因為3沒有比4大，小哲無法擊敗小昌，全國第一仍是小昌
6. 以下類推其他全部縣市，經過層層比較，最後選出最高分的全國第一名

假設s為`abbde`

設定一變數`ans`，紀錄全國第一名，初始設定為`0`

### 索引起點`0`
~~（舉辦基隆市比賽）~~

設定索引起點為`0`，`s[0] = a`，尋找以`a`為起點的所有排列  
並且，同時紀錄**不重複字元：j**出現的次數

- `a`: j = 1
- `ab`: j = 2
- `abb`: j = 2
- `abbd`: j = 3
- `abbde`: j = 4

這一輪最大的j得到4，因為4比全國第一名`ans=0`大，讓`ans=4`

### 索引起點`1`
~~（舉辦台北市比賽）~~

往後移動索引為`1`，`s[1] = b`，尋找以b為起點的所有排列，紀錄不重複字元j出現次數

經過一串計算後，得知本輪j最大為`3`  
`3`沒有比`ans=4`大，所以ans還是等於4

繼續計算索引起點`2`、`3`等等，最終得到ans為4

### `seen`紀錄重複出現的字元

前面算`j`時，會利用到`seen`這一vector比對，`seen`會計算已經出現過的字元次數

由於Leetcode字元是ASCII，一共只有128項，因此首先讓`seen`為128個空值的vector

```cpp
vector<int> seen(128);
```

而當回圈計算到`a`時，首先查詢`seen`裡面是否有`a`

```cpp
seen[a];
```

中括號裡面通常是放常數，代表索引，強硬塞給他字符`a`，他會轉換成ASCII的數字，`a`的ASCII碼是`97`，因此實際上會變成

```cpp
seen[97];
```

尋找`seen`當中第97項的值，目前因為128項都是nil，因此會得到nil，也就是沒找到的結果  
因為確定沒找到，認定`a`為尚未出現過的字符，所以將他記錄到`seen`當中，以供下次搜尋使用

### 程式碼欣賞

```cpp
seen[a]++;
```

`a`會變轉化成索引`97`，`seen[97]`原本是空值，`++`後等於`1`，所以`seen[97]`等於了`1`

```cpp
class Solution {
public:
    
    int lengthOfLongestSubstring(string s) {
        
        // 取字串的長度
        int n = s.length();
        
        // 總第一名
        int ans = 0;
        
        for (int i = 0; i < n; ++i) {
            // 建立名為seen的vector，紀錄出現過的字符，因為leetcode的字元總共只有128個，所以一口氣將所有字符的空格都畫出來
            vector<int> seen(128);
            
            // 最長的不重複字元次數
            int j = i;
            
            // 當j還沒觸及s的終點，並且字符s[j]為新出現的字符，往下計算
            while(j < n && !seen[s[j]]) {
                // 因為s[j]出現過了，標記為已出現，s[j]由nil變成1
                seen[s[j]]++;
                
                // 出現了新的不重複字元，j加1
                j++;
                
            }
            
            // 因為開頭定義j=i，造成j初始具有偏移，因此需要再進行補正
            ans = max(ans, j - i);
            
        }
        
        return ans;
    }
};
```
